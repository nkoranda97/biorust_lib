from __future__ import annotations
from typing import Iterable, Literal, overload

class Scoring:
    def __init__(
        self,
        match_score: int | float = ...,
        mismatch_score: int | float = ...,
        gap_open: int | float = ...,
        gap_extend: int | float = ...,
        matrix: list[int] | str | None = ...,
        alphabet_size: int | None = ...,
        end_gap: bool = ...,
        end_gap_open: float | None = ...,
        end_gap_extend: float | None = ...,
        use_matrix: bool = ...,
    ) -> None: ...
    @staticmethod
    def with_matrix(
        matrix: list[int],
        alphabet_size: int,
        gap_open: int | float = ...,
        gap_extend: int | float = ...,
        end_gap: bool = ...,
        end_gap_open: float | None = ...,
        end_gap_extend: float | None = ...,
    ) -> Scoring: ...
    @staticmethod
    def matrix_names() -> list[str]: ...

class AlignmentResult:
    @property
    def score(self) -> float: ...
    @property
    def query_end(self) -> int: ...
    @property
    def target_end(self) -> int: ...
    @property
    def query_start(self) -> int | None: ...
    @property
    def target_start(self) -> int | None: ...
    @property
    def cigar(self) -> list[tuple[str, int]] | None: ...
    def aligned_strings(self) -> tuple[str, str]: ...
    def alignment_diagram(self) -> str: ...

class DNA:
    def __init__(self, seq: str | bytes | bytearray | memoryview) -> None: ...
    def reverse_complement(self) -> DNA: ...
    def complement(self) -> DNA: ...
    def translate(self) -> Protein: ...
    def to_bytes(self) -> bytes: ...
    def __len__(self) -> int: ...
    def __bytes__(self) -> bytes: ...
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...

    # comparisons
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __lt__(self, other: object) -> bool: ...
    def __le__(self, other: object) -> bool: ...
    def __gt__(self, other: object) -> bool: ...
    def __ge__(self, other: object) -> bool: ...

    # concatenation
    def __add__(self, other: DNA) -> DNA: ...

    # mul
    def __mul__(self, other: int) -> "DNA": ...
    def __rmul__(self, other: int) -> "DNA": ...

    # indexing
    @overload
    def __getitem__(self, other: int) -> "DNA": ...
    @overload
    def __getitem__(self, other: slice) -> "DNA": ...
    def __getitem__(self, other): ...
    def count(self, other: str | bytes | bytearray | memoryview | int | DNA) -> int: ...
    def count_overlap(
        self, sub: DNA | str | bytes | bytearray | memoryview | int
    ) -> int: ...
    def __contains__(
        self, other: str | bytes | bytearray | memoryview | int | DNA
    ) -> bool: ...
    def find(
        self,
        sub: str | bytes | bytearray | memoryview | int | "DNA",
        start: int | None = ...,
        end: int | None = ...,
    ) -> int: ...
    def index(
        self,
        sub: str | bytes | bytearray | memoryview | int | "DNA",
        start: int | None = ...,
        end: int | None = ...,
    ) -> int: ...
    def rfind(
        self,
        sub: str | bytes | bytearray | memoryview | int | "DNA",
        start: int | None = ...,
        end: int | None = ...,
    ) -> int: ...
    def rindex(
        self,
        sub: str | bytes | bytearray | memoryview | int | "DNA",
        start: int | None = ...,
        end: int | None = ...,
    ) -> int: ...
    def split(
        self,
        sep: str | bytes | bytearray | memoryview | int | "DNA" | None = ...,
        maxsplit: int = ...,
    ) -> list["DNA"]: ...
    def rsplit(
        self,
        sep: str | bytes | bytearray | memoryview | int | "DNA" | None = ...,
        maxsplit: int = ...,
    ) -> list["DNA"]: ...
    def strip(
        self,
        chars: str | bytes | bytearray | memoryview | int | "DNA" | None = ...,
    ) -> "DNA": ...
    def lstrip(
        self,
        chars: str | bytes | bytearray | memoryview | int | "DNA" | None = ...,
    ) -> "DNA": ...
    def rstrip(
        self,
        chars: str | bytes | bytearray | memoryview | int | "DNA" | None = ...,
    ) -> "DNA": ...
    def upper(self) -> "DNA": ...
    def lower(self) -> "DNA": ...
    def startswith(
        self,
        sub: str
        | bytes
        | bytearray
        | memoryview
        | int
        | "DNA"
        | tuple[str | bytes | bytearray | memoryview | int | "DNA", ...],
        start: int | None = ...,
        end: int | None = ...,
    ) -> bool: ...
    def endswith(
        self,
        sub: str
        | bytes
        | bytearray
        | memoryview
        | int
        | "DNA"
        | tuple[str | bytes | bytearray | memoryview | int | "DNA", ...],
        start: int | None = ...,
        end: int | None = ...,
    ) -> bool: ...

class DNARecord:
    def __init__(self, id: str, seq: DNA, desc: str | None = ...) -> None: ...
    @property
    def id(self) -> str: ...
    @property
    def description(self) -> str | None: ...
    @property
    def seq(self) -> DNA: ...
    def __repr__(self) -> str: ...

class DNARecordBatch:
    def __init__(self, records: Iterable[DNARecord] | "DNARecordBatch") -> None: ...
    def __len__(self) -> int: ...
    @overload
    def __getitem__(self, other: int) -> DNARecord: ...
    @overload
    def __getitem__(self, other: slice) -> "DNARecordBatch": ...
    def __getitem__(self, other): ...
    def ids(self) -> list[str]: ...
    def descriptions(self) -> list[str | None]: ...
    def seqs(self) -> "DNABatch": ...
    @property
    def skipped(self) -> list["SkippedRecord"]: ...
    @overload
    def reverse_complements(
        self, inplace: Literal[False] = ...
    ) -> "DNARecordBatch": ...
    @overload
    def reverse_complements(self, inplace: Literal[True]) -> None: ...

class ProteinRecord:
    def __init__(self, id: str, seq: Protein, desc: str | None = ...) -> None: ...
    @property
    def id(self) -> str: ...
    @property
    def description(self) -> str | None: ...
    @property
    def seq(self) -> Protein: ...
    def __repr__(self) -> str: ...

class ProteinRecordBatch:
    def __init__(
        self, records: Iterable[ProteinRecord] | "ProteinRecordBatch"
    ) -> None: ...
    def __len__(self) -> int: ...
    @overload
    def __getitem__(self, other: int) -> ProteinRecord: ...
    @overload
    def __getitem__(self, other: slice) -> "ProteinRecordBatch": ...
    def __getitem__(self, other): ...
    def ids(self) -> list[str]: ...
    def descriptions(self) -> list[str | None]: ...
    def seqs(self) -> "ProteinBatch": ...
    @property
    def skipped(self) -> list["SkippedRecord"]: ...

class SkippedRecord:
    @property
    def row(self) -> int: ...
    @property
    def id(self) -> str | None: ...
    @property
    def column(self) -> str: ...
    @property
    def message(self) -> str: ...
    def __repr__(self) -> str: ...

class DNABatch:
    def __init__(self, seqs: Iterable[DNA]) -> None: ...
    def __len__(self) -> int: ...
    @overload
    def __getitem__(self, other: int) -> DNA: ...
    @overload
    def __getitem__(self, other: slice) -> "DNABatch": ...
    def __getitem__(self, other): ...
    def __iter__(self): ...
    def to_list(self) -> list[DNA]: ...
    def lengths(self) -> list[int]: ...
    def append(self, seq: DNA) -> None: ...
    def extend(self, seqs: Iterable[DNA] | "DNABatch") -> None: ...
    def clear(self) -> None: ...
    def reserve(self, additional: int) -> None: ...
    def pop(self) -> DNA: ...
    def truncate(self, len: int) -> None: ...
    def __iadd__(self, other: Iterable[DNA] | "DNABatch") -> "DNABatch": ...
    def __imul__(self, n: int) -> "DNABatch": ...
    @overload
    def reverse_complements(self, inplace: Literal[False] = ...) -> "DNABatch": ...
    @overload
    def reverse_complements(self, inplace: Literal[True]) -> None: ...
    def reverse_complements_in_place(self) -> None: ...

class Protein:
    def __init__(self, seq: str | bytes | bytearray | memoryview) -> None: ...
    def to_bytes(self) -> bytes: ...
    def __len__(self) -> int: ...
    def __bytes__(self) -> bytes: ...
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...
    def reverse(self) -> "Protein": ...
    def counts(self) -> list[tuple[str, int]]: ...
    def frequencies(self) -> list[tuple[str, float]]: ...
    def aa_counts_20(self) -> list[tuple[str, int]]: ...
    def aa_frequencies_20(self) -> list[tuple[str, float]]: ...
    def shannon_entropy(self) -> float: ...
    def molecular_weight(self) -> float: ...
    def hydrophobicity(self) -> float: ...
    def hydrophobicity_profile(self, window: int) -> list[float]: ...
    def net_charge(self, ph: float) -> float: ...
    def isoelectric_point(self) -> float: ...
    def validate_strict_20(self) -> None: ...
    def has_ambiguous(self) -> bool: ...
    def unknown_positions(self) -> list[int]: ...

    # comparisons
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __lt__(self, other: object) -> bool: ...
    def __le__(self, other: object) -> bool: ...
    def __gt__(self, other: object) -> bool: ...
    def __ge__(self, other: object) -> bool: ...

    # concatenation
    def __add__(self, other: Protein) -> Protein: ...

    # mul
    def __mul__(self, other: int) -> Protein: ...
    def __rmul__(self, other: int) -> Protein: ...

    # indexing
    @overload
    def __getitem__(self, other: int) -> Protein: ...
    @overload
    def __getitem__(self, other: slice) -> Protein: ...
    def __getitem__(self, other): ...
    def count(
        self, other: str | bytes | bytearray | memoryview | int | Protein
    ) -> int: ...
    def count_overlap(
        self, sub: Protein | str | bytes | bytearray | memoryview | int
    ) -> int: ...
    def __contains__(
        self, other: str | bytes | bytearray | memoryview | int | Protein
    ) -> bool: ...
    def find(
        self,
        sub: str | bytes | bytearray | memoryview | int | Protein,
        start: int | None = ...,
        end: int | None = ...,
    ) -> int: ...
    def index(
        self,
        sub: str | bytes | bytearray | memoryview | int | Protein,
        start: int | None = ...,
        end: int | None = ...,
    ) -> int: ...
    def rfind(
        self,
        sub: str | bytes | bytearray | memoryview | int | Protein,
        start: int | None = ...,
        end: int | None = ...,
    ) -> int: ...
    def rindex(
        self,
        sub: str | bytes | bytearray | memoryview | int | Protein,
        start: int | None = ...,
        end: int | None = ...,
    ) -> int: ...
    def split(
        self,
        sep: str | bytes | bytearray | memoryview | int | Protein | None = ...,
        maxsplit: int = ...,
    ) -> list[Protein]: ...
    def rsplit(
        self,
        sep: str | bytes | bytearray | memoryview | int | Protein | None = ...,
        maxsplit: int = ...,
    ) -> list[Protein]: ...
    def strip(
        self,
        chars: str | bytes | bytearray | memoryview | int | Protein | None = ...,
    ) -> Protein: ...
    def lstrip(
        self,
        chars: str | bytes | bytearray | memoryview | int | Protein | None = ...,
    ) -> Protein: ...
    def rstrip(
        self,
        chars: str | bytes | bytearray | memoryview | int | Protein | None = ...,
    ) -> Protein: ...
    def upper(self) -> Protein: ...
    def lower(self) -> Protein: ...
    def startswith(
        self,
        sub: str
        | bytes
        | bytearray
        | memoryview
        | int
        | Protein
        | tuple[str | bytes | bytearray | memoryview | int | Protein, ...],
        start: int | None = ...,
        end: int | None = ...,
    ) -> bool: ...
    def endswith(
        self,
        sub: str
        | bytes
        | bytearray
        | memoryview
        | int
        | Protein
        | tuple[str | bytes | bytearray | memoryview | int | Protein, ...],
        start: int | None = ...,
        end: int | None = ...,
    ) -> bool: ...

class ProteinBatch:
    def __init__(self, seqs: Iterable[Protein]) -> None: ...
    def __len__(self) -> int: ...
    @overload
    def __getitem__(self, other: int) -> Protein: ...
    @overload
    def __getitem__(self, other: slice) -> "ProteinBatch": ...
    def __getitem__(self, other): ...
    def __iter__(self): ...
    def to_list(self) -> list[Protein]: ...
    def lengths(self) -> list[int]: ...
    def append(self, seq: Protein) -> None: ...
    def extend(self, seqs: Iterable[Protein] | "ProteinBatch") -> None: ...
    def clear(self) -> None: ...
    def reserve(self, additional: int) -> None: ...
    def pop(self) -> Protein: ...
    def truncate(self, len: int) -> None: ...
    def __iadd__(self, other: Iterable[Protein] | "ProteinBatch") -> "ProteinBatch": ...
    def __imul__(self, n: int) -> "ProteinBatch": ...

def complement(seq: str | bytes | bytearray | memoryview | DNA) -> DNA: ...
def read_fasta(path: str) -> DNARecordBatch: ...
@overload
def read_csv(
    path: str,
    *,
    id_col: str | int,
    seq_col: str | int,
    desc_col: str | int | None = ...,
    alphabet: Literal["dna"] = ...,
    on_error: Literal["raise", "skip"] = ...,
) -> DNARecordBatch: ...
@overload
def read_csv(
    path: str,
    *,
    id_col: str | int,
    seq_col: str | int,
    desc_col: str | int | None = ...,
    alphabet: Literal["protein"],
    on_error: Literal["raise", "skip"] = ...,
) -> ProteinRecordBatch: ...
def read_csv(
    path: str,
    *,
    id_col: str | int,
    seq_col: str | int,
    desc_col: str | int | None = ...,
    alphabet: str = ...,
    on_error: str = ...,
) -> DNARecordBatch | ProteinRecordBatch: ...
def csv_columns(path: str) -> list[str]: ...
def align_local(
    query: DNA | Protein,
    target: DNA | Protein,
    scoring: Scoring,
    traceback: bool = ...,
) -> AlignmentResult: ...
def align_global(
    query: DNA | Protein,
    target: DNA | Protein,
    scoring: Scoring,
    traceback: bool = ...,
) -> AlignmentResult: ...
