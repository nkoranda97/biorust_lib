from __future__ import annotations
from typing import overload

class DNA:
    def __init__(self, seq: str | bytes | bytearray | memoryview | DNA) -> None: ...
    def reverse_complement(self) -> DNA: ...
    def to_bytes(self) -> bytes: ...
    def __len__(self) -> int: ...
    def __bytes__(self) -> bytes: ...
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...

    # comparisons
    def __eq__(self, other: str | bytes | bytearray | memoryview | DNA) -> bool: ...
    def __ne__(self, other: str | bytes | bytearray | memoryview | DNA) -> bool: ...
    def __lt__(self, other: str | bytes | bytearray | memoryview | DNA) -> bool: ...
    def __le__(self, other: str | bytes | bytearray | memoryview | DNA) -> bool: ...
    def __gt__(self, other: str | bytes | bytearray | memoryview | DNA) -> bool: ...
    def __ge__(self, other: str | bytes | bytearray | memoryview | DNA) -> bool: ...

    # concatenation
    def __add__(self, other: str | bytes | bytearray | memoryview | DNA) -> DNA: ...
    def __radd__(self, other: str | bytes | bytearray | memoryview | DNA) -> DNA: ...

    # mul
    def __mul__(self, other: int) -> "DNA": ...
    def __rmul__(self, other: int) -> "DNA": ...

    # indexing
    @overload
    def __getitem__(self, other: int) -> "DNA": ...
    @overload
    def __getitem__(self, other: slice) -> "DNA": ...
    def __getitem__(self, other): ...
    def count(self, other: str | bytes | bytearray | memoryview | DNA) -> int: ...
    def count_overlap(
        self, sub: DNA | str | bytes | bytearray | memoryview | int
    ) -> int: ...

def complement(a: int) -> int: ...
